# 第十一周

## 生产者消费者问题

#### 概念表达
生產者-消費者（Producer-Consumer）問題是一個著名的進程/線程的同步問題。

* 它描述的是：有一群生產者在生產產品，並將這些產品提供給消費者去消費
* 為了使生產者與消費者能並發執行，在兩者之間設置了一個具有n個緩沖區的緩沖池
* 【生產者】將生產的產品放入緩沖區中；不允許生產者向一個已裝滿產品的緩沖區投放產品
* 【消費者】從緩沖區中取走產品去消費；不允許消費者到一個空緩沖區去取產品
* 所有的生產者和消費者進程或線程都是以異步的方式運行的，但它們之間必須保持同步

也称有限缓衝问题（Bounded-buffer problem）
* 共享固定大小缓衝区的两个进程「生产者」和「消费者」在实际运行时会发生的问题。
* 生产者的主要作用是生成一定量的数据放到缓衝区中，然后重複此过程，与此同时，消费者也在缓衝区消耗这些数据。
* 保证生产者不会在缓衝区满时加入数据，消费者也不会在缓衝区中空时消耗数据。

## 哲学家用餐问题
#### 概念表达
哲学家就餐问题是在计算机科学中的一个经典问题，用来演示在并行计算中多线程同步(Synchronization)时产生的问题。在1971年，著名的计算机科学家艾兹格·迪科斯彻提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。
稍后，这个问题被托尼·霍尔重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。

#### 问题详情
哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。
哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。
在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而这永远不会发生。

#### 解决方法
* 服务生解法
* 
一个简单的解法是引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉。因为服务生知道哪只餐叉正在使用，所以他能够作出判断避免死锁。
为了演示这种解法，假设哲学家依次标号为A至E。如果A和C在吃东西，则有四只餐叉在使用中。B坐在A和C之间，所以两只餐叉都无法使用，而D和E之间有一只空余的餐叉。假设这时D想要吃东西。如果他拿起了第五只餐叉，就有可能发生死锁。相反，如果他征求服务生同意，服务生会让他等待。这样，我们就能保证下次当两把餐叉空余出来时，一定有一位哲学家可以成功的得到一对餐叉，从而避免了死锁。
* 资源分级解法
* 
另一个简单的解法是为资源（这里是餐叉）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。
尽管资源分级能避免死锁，但这种策略并不总是实用的，特别是当所需资源的列表并不是事先知道的时候。例如，假设一个工作单元拿着资源3和5，并决定需要资源2，则必须先要释放5，之后释放3，才能得到2，之后必须重新按顺序获取3和5。对需要访问大量数据库记录的计算机程序来说，如果需要先释放高编号的记录才能访问新的记录，那么运行效率就不会高，因此这种方法在这里并不实用。


## Semaphore
* 号志（semaphore）又称为旗号，是一个同步物件，用于保持在0至指定最大值之间的一个计数值。
* 当执行绪完成一次对 semaphore 物件的等待( wait )时，该计数值减一，当执行绪完成一次对 semaphore 物件的释放( release ) 时，计数值加一。
* semaphore 的值为任意正整数时， 被称为计数号志(Counting semaphore)
* semaphore 的值为二进位的 0 或 1 ，则称为二进位号志(binary semaphore)

![image](https://user-images.githubusercontent.com/62127656/121330695-d4cd8880-c948-11eb-9234-7a7b40154e83.png)

## Mutex (Mutual exclusion) 
* 一种用于多执行绪编程中，防止两条执行绪同时对同一公共资源（比如全域变数）进行读写的机制。
* 需要此机制的资源的例子有：旗标、伫列、计数器、中断处理程式等用于在多条并列执行的代码间传递资料、同步状态等的资源。
* 不准永远耽搁一个要求进入临界区域的执行绪，造成死结或是飢饿发生 。

> 参考资料：百度百科
